// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

/**
 * @title IPNDCPoolManager
 * @dev Interface for the main pool management contract
 */
interface IPNDCPoolManager {
    function getPoolInfo(uint256 poolId) external view returns (
        address labelToken,
        uint256 goal,
        uint256 currentAmount,
        uint256 deadline,
        bool isActive,
        bool goalMet,
        bool hasWon,
        address multisigWallet,
        uint256 winningAuctionId
    );
    
    function isPoolEligibleForBid(uint256 poolId) external view returns (bool);
    function markPoolAsWinner(uint256 poolId, uint256 auctionId) external;
    function distributeRewards(uint256 poolId, uint256 auctionId, address rewardToken, uint256 amount, uint8 targetChain) external;
}

/**
 * @title PoolStructs
 * @dev Library containing all data structures used across contracts
 */
library PoolStructs {
    struct Pool {
        address labelToken;         // SPL or ERC-20 token address this pool represents
        uint256 goal;              // Target amount (50B to 1T PNDC)
        uint256 currentAmount;     // Current pooled amount
        uint256 deadline;          // Timestamp when pool expires
        bool isActive;             // Whether pool is accepting contributions
        bool goalMet;              // Whether goal has been reached
        bool hasWon;               // Whether pool won an auction
        bool isComplete;           // Whether pool is permanently closed
        address ethMultisigWallet; // Associated ETH multisig wallet
        address solMultisigWallet; // Associated SOL multisig wallet (encoded as address)
        uint256 winningAuctionId;  // ID of auction this pool won
        mapping(address => uint256) contributions; // User contributions
        address[] contributors;    // List of all contributors
        uint256 totalContributors; // Count of unique contributors
        mapping(uint256 => RewardInfo) auctionRewards; // Rewards per auction
    }
    
    struct RewardInfo {
        uint256 totalAmount;       // Total rewards received
        address rewardToken;       // Token used for rewards
        uint8 targetChain;         // 1 = Ethereum, 2 = Solana
        bool distributed;          // Whether rewards have been distributed
        mapping(address => uint256) userRewards; // Individual user rewards
    }
    
    struct UserContribution {
        uint256 amount;
        uint256 timestamp;
        mapping(uint256 => bool) rewardsClaimed; // Per auction rewards claimed
    }
    
    struct AuctionState {
        uint256 auctionId;         // Unique auction identifier
        bool isActive;
        uint256 startTime;
        uint256 endTime;
        uint256[] eligiblePools;
        uint256[] winningPools;    // Multiple pools can win different auctions
        mapping(uint256 => bool) poolWon; // Track which pools won
    }
    
    struct CrossChainMessage {
        uint256 auctionId;
        uint256 poolId;
        address rewardToken;
        uint256 amount;
        uint8 sourceChain;
        uint8 targetChain;
        bytes32 messageHash;
        bool processed;
    }
}

/**
 * @title PNDCPoolManager
 * @dev Main contract for managing PNDC token pools with multi-auction support
 */
contract PNDCPoolManager is IPNDCPoolManager, ReentrancyGuard, Ownable, Pausable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    
    // Constants
    uint256 public constant MIN_GOAL = 50_000_000_000 * 10**18; // 50 billion PNDC
    uint256 public constant MAX_GOAL = 1_000_000_000_000 * 10**18; // 1 trillion PNDC
    uint256 public constant GOAL_INCREMENT = 50_000_000_000 * 10**18; // 50 billion increments
    uint256 public constant MAX_POOL_AMOUNT = 1_000_000_000_000 * 10**18; // 1 trillion max
    uint256 public constant MIN_WEEKS = 1;
    uint256 public constant MAX_WEEKS = 25;
    uint256 public constant WEEK_IN_SECONDS = 604800; // 1 week in seconds
    uint256 public constant SYSTEM_FEE_PERCENTAGE = 3; // 3% system fee
    
    // Chain identifiers
    uint8 public constant ETHEREUM_CHAIN = 1;
    uint8 public constant SOLANA_CHAIN = 2;
    
    // State variables
    IERC20 public pndcToken;
    address public auctionManager;
    address public rewardDistributor;
    address public crossChainRewardManager;
    uint256 public nextPoolId;
    
    // Mappings
    mapping(uint256 => PoolStructs.Pool) public pools;
    mapping(address => uint256[]) public userPools; // User's participated pools
    mapping(uint256 => mapping(address => PoolStructs.UserContribution)) public userContributions;
    mapping(uint256 => uint256[]) public auctionWinners; // auctionId => winning pool IDs
    mapping(uint256 => mapping(uint256 => bool)) public auctionPoolWins; // auctionId => poolId => won
    
    // Events
    event PoolCreated(
        uint256 indexed poolId,
        address indexed creator,
        address indexed labelToken,
        uint256 goal,
        uint256 deadline,
        address ethMultisig,
        address solMultisig
    );
    
    event ContributionMade(
        uint256 indexed poolId,
        address indexed contributor,
        uint256 amount,
        uint256 newTotal
    );
    
    event GoalReached(uint256 indexed poolId, uint256 totalAmount);
    event PoolWon(uint256 indexed poolId, uint256 indexed auctionId, uint256 bidAmount);
    event RewardsReceived(uint256 indexed poolId, uint256 indexed auctionId, address rewardToken, uint256 amount, uint8 targetChain);
    event RewardsDistributed(uint256 indexed poolId, uint256 indexed auctionId, address indexed user, uint256 amount);
    event PoolExpired(uint256 indexed poolId);
    event TokensReturned(uint256 indexed poolId, address indexed user, uint256 amount);
    event CrossChainRewardInitiated(uint256 indexed poolId, uint256 indexed auctionId, uint8 targetChain);
    
    // Modifiers
    modifier onlyAuctionManager() {
        require(msg.sender == auctionManager, "Only auction manager can call this");
        _;
    }
    
    modifier onlyRewardDistributor() {
        require(msg.sender == rewardDistributor, "Only reward distributor can call this");
        _;
    }
    
    modifier onlyCrossChainManager() {
        require(msg.sender == crossChainRewardManager, "Only cross-chain manager can call this");
        _;
    }
    
    modifier validPool(uint256 poolId) {
        require(poolId < nextPoolId, "Pool does not exist");
        _;
    }
    
    modifier poolActive(uint256 poolId) {
        require(pools[poolId].isActive, "Pool is not active");
        require(block.timestamp <= pools[poolId].deadline, "Pool has expired");
        require(!pools[poolId].isComplete, "Pool is complete");
        _;
    }
    
    constructor(
        address _pndcToken,
        address _auctionManager,
        address _rewardDistributor,
        address _crossChainRewardManager
    ) {
        pndcToken = IERC20(_pndcToken);
        auctionManager = _auctionManager;
        rewardDistributor = _rewardDistributor;
        crossChainRewardManager = _crossChainRewardManager;
        nextPoolId = 1;
    }
    
    /**
     * @dev Create a new pool with both ETH and SOL multisig support
     */
    function createPool(
        address labelToken,
        uint256 goal,
        uint256 durationWeeks,
        address ethMultisigWallet,
        address solMultisigWallet
    ) external nonReentrant whenNotPaused returns (uint256) {
        require(labelToken != address(0), "Invalid label token");
        require(ethMultisigWallet != address(0), "Invalid ETH multisig wallet");
        require(solMultisigWallet != address(0), "Invalid SOL multisig wallet");
        require(goal >= MIN_GOAL && goal <= MAX_GOAL, "Invalid goal amount");
        require(goal % GOAL_INCREMENT == 0, "Goal must be in 50B increments");
        require(durationWeeks >= MIN_WEEKS && durationWeeks <= MAX_WEEKS, "Invalid duration");
        
        uint256 poolId = nextPoolId++;
        PoolStructs.Pool storage newPool = pools[poolId];
        
        newPool.labelToken = labelToken;
        newPool.goal = goal;
        newPool.currentAmount = 0;
        newPool.deadline = block.timestamp + (durationWeeks * WEEK_IN_SECONDS);
        newPool.isActive = true;
        newPool.goalMet = false;
        newPool.hasWon = false;
        newPool.isComplete = false;
        newPool.ethMultisigWallet = ethMultisigWallet;
        newPool.solMultisigWallet = solMultisigWallet;
        newPool.totalContributors = 0;
        newPool.winningAuctionId = 0;
        
        emit PoolCreated(poolId, msg.sender, labelToken, goal, newPool.deadline, ethMultisigWallet, solMultisigWallet);
        
        return poolId;
    }
    
    /**
     * @dev Contribute PNDC tokens to a pool
     */
    function contributeToPool(uint256 poolId, uint256 amount) 
        external 
        nonReentrant 
        whenNotPaused 
        validPool(poolId) 
        poolActive(poolId) 
    {
        require(amount > 0, "Amount must be greater than 0");
        
        PoolStructs.Pool storage pool = pools[poolId];
        
        // Check if pool is accepting contributions (not during active auction if goal met)
        if (pool.goalMet) {
            require(!_isAuctionActive(), "Pool not accepting contributions during auction");
        }
        
        require(pool.currentAmount + amount <= MAX_POOL_AMOUNT, "Pool would exceed maximum capacity");
        
        // Transfer tokens from user to ETH multisig wallet (primary storage)
        pndcToken.safeTransferFrom(msg.sender, pool.ethMultisigWallet, amount);
        
        // Update pool state
        pool.currentAmount += amount;
        
        // Track user contribution
        if (pool.contributions[msg.sender] == 0) {
            pool.contributors.push(msg.sender);
            pool.totalContributors++;
            userPools[msg.sender].push(poolId);
        }
        
        pool.contributions[msg.sender] += amount;
        userContributions[poolId][msg.sender].amount += amount;
        userContributions[poolId][msg.sender].timestamp = block.timestamp;
        
        // Check if goal is reached
        if (!pool.goalMet && pool.currentAmount >= pool.goal) {
            pool.goalMet = true;
            emit GoalReached(poolId, pool.currentAmount);
        }
        
        emit ContributionMade(poolId, msg.sender, amount, pool.currentAmount);
    }
    
    /**
     * @dev Get pool information with auction ID
     */
    function getPoolInfo(uint256 poolId) 
        external 
        view 
        override 
        validPool(poolId) 
        returns (
            address labelToken,
            uint256 goal,
            uint256 currentAmount,
            uint256 deadline,
            bool isActive,
            bool goalMet,
            bool hasWon,
            address multisigWallet,
            uint256 winningAuctionId
        ) 
    {
        PoolStructs.Pool storage pool = pools[poolId];
        return (
            pool.labelToken,
            pool.goal,
            pool.currentAmount,
            pool.deadline,
            pool.isActive,
            pool.goalMet,
            pool.hasWon,
            pool.ethMultisigWallet, // Return primary multisig
            pool.winningAuctionId
        );
    }
    
    /**
     * @dev Get both multisig addresses for a pool
     */
    function getPoolMultisigs(uint256 poolId) external view validPool(poolId) returns (address ethMultisig, address solMultisig) {
        PoolStructs.Pool storage pool = pools[poolId];
        return (pool.ethMultisigWallet, pool.solMultisigWallet);
    }
    
    /**
     * @dev Check if pool is eligible for bidding
     */
    function isPoolEligibleForBid(uint256 poolId) external view override returns (bool) {
        PoolStructs.Pool storage pool = pools[poolId];
        return pool.isActive && 
               pool.goalMet && 
               !pool.hasWon && 
               !pool.isComplete && 
               block.timestamp <= pool.deadline;
    }
    
    /**
     * @dev Mark pool as auction winner with auction ID tracking
     */
    function markPoolAsWinner(uint256 poolId, uint256 auctionId) external override onlyAuctionManager {
        PoolStructs.Pool storage pool = pools[poolId];
        require(pool.goalMet, "Pool goal not met");
        require(!pool.hasWon, "Pool already won");
        require(auctionId > 0, "Invalid auction ID");
        
        pool.hasWon = true;
        pool.winningAuctionId = auctionId;
        pool.isActive = false; // Stop accepting new contributions
        
        // Track auction winners
        auctionWinners[auctionId].push(poolId);
        auctionPoolWins[auctionId][poolId] = true;
        
        emit PoolWon(poolId, auctionId, pool.currentAmount);
    }
    
    /**
     * @dev Distribute rewards for specific auction with cross-chain support
     */
    function distributeRewards(
        uint256 poolId, 
        uint256 auctionId, 
        address rewardToken, 
        uint256 amount,
        uint8 targetChain
    ) external override onlyRewardDistributor {
        PoolStructs.Pool storage pool = pools[poolId];
        require(pool.hasWon, "Pool has not won an auction");
        require(pool.winningAuctionId == auctionId, "Auction ID mismatch");
        require(auctionPoolWins[auctionId][poolId], "Pool did not win this auction");
        require(targetChain == ETHEREUM_CHAIN || targetChain == SOLANA_CHAIN, "Invalid target chain");
        
        // Initialize reward info for this auction
        PoolStructs.RewardInfo storage rewardInfo = pool.auctionRewards[auctionId];
        require(!rewardInfo.distributed, "Rewards already distributed for this auction");
        
        rewardInfo.totalAmount = amount;
        rewardInfo.rewardToken = rewardToken;
        rewardInfo.targetChain = targetChain;
        
        emit RewardsReceived(poolId, auctionId, rewardToken, amount, targetChain);
        
        if (targetChain == ETHEREUM_CHAIN) {
            _distributeRewardsOnEthereum(poolId, auctionId, rewardToken, amount);
        } else {
            _initiateCrossChainDistribution(poolId, auctionId, rewardToken, amount);
        }
    }
    
    /**
     * @dev Internal function to distribute rewards on Ethereum
     */
    function _distributeRewardsOnEthereum(uint256 poolId, uint256 auctionId, address rewardToken, uint256 amount) internal {
        PoolStructs.Pool storage pool = pools[poolId];
        PoolStructs.RewardInfo storage rewardInfo = pool.auctionRewards[auctionId];
        
        // Calculate system fee (3%)
        uint256 systemFee = (amount * SYSTEM_FEE_PERCENTAGE) / 100;
        uint256 userRewards = amount - systemFee;
        
        // Transfer system fee to owner
        IERC20(rewardToken).safeTransfer(owner(), systemFee);
        
        // Distribute rewards proportionally
        for (uint256 i = 0; i < pool.contributors.length; i++) {
            address contributor = pool.contributors[i];
            uint256 userContribution = pool.contributions[contributor];
            uint256 userReward = (userRewards * userContribution) / pool.currentAmount;
            
            if (userReward > 0) {
                rewardInfo.userRewards[contributor] = userReward;
                IERC20(rewardToken).safeTransfer(contributor, userReward);
                userContributions[poolId][contributor].rewardsClaimed[auctionId] = true;
                emit RewardsDistributed(poolId, auctionId, contributor, userReward);
            }
        }
        
        rewardInfo.distributed = true;
        
        // Check if all auctions for this pool are complete
        if (_allAuctionRewardsDistributed(poolId)) {
            pool.isComplete = true;
        }
    }
    
    /**
     * @dev Initiate cross-chain reward distribution to Solana
     */
    function _initiateCrossChainDistribution(uint256 poolId, uint256 auctionId, address rewardToken, uint256 amount) internal {
        // This would integrate with cross-chain bridge
        emit CrossChainRewardInitiated(poolId, auctionId, SOLANA_CHAIN);
        
        // Mark as distributed since cross-chain manager will handle actual distribution
        pools[poolId].auctionRewards[auctionId].distributed = true;
    }
    
    /**
     * @dev Check if all auction rewards have been distributed for a pool
     */
    function _allAuctionRewardsDistributed(uint256 poolId) internal view returns (bool) {
        // This would check all auctions the pool participated in
        // For now, simplified to single auction
        return pools[poolId].auctionRewards[pools[poolId].winningAuctionId].distributed;
    }
    
    /**
     * @dev Get user's reward for specific auction
     */
    function getUserRewardForAuction(uint256 poolId, uint256 auctionId, address user) external view returns (uint256) {
        return pools[poolId].auctionRewards[auctionId].userRewards[user];
    }
    
    /**
     * @dev Get auction winners
     */
    function getAuctionWinners(uint256 auctionId) external view returns (uint256[] memory) {
        return auctionWinners[auctionId];
    }
    
    /**
     * @dev Return tokens to users when pool expires without winning
     */
    function returnTokensOnExpiry(uint256 poolId) external nonReentrant {
        PoolStructs.Pool storage pool = pools[poolId];
        require(block.timestamp > pool.deadline, "Pool has not expired");
        require(!pool.hasWon, "Pool has won, cannot return tokens");
        require(!pool.isComplete, "Pool already processed");
        
        // Return tokens to all contributors
        for (uint256 i = 0; i < pool.contributors.length; i++) {
            address contributor = pool.contributors[i];
            uint256 contributionAmount = pool.contributions[contributor];
            
            if (contributionAmount > 0) {
                // Transfer tokens back from multisig to contributor
                // This would require multisig approval in practice
                emit TokensReturned(poolId, contributor, contributionAmount);
            }
        }
        
        pool.isActive = false;
        pool.isComplete = true;
        
        emit PoolExpired(poolId);
    }
    
    /**
     * @dev Get eligible pools for bidding (sorted by amount descending)
     */
    function getEligiblePools() external view returns (uint256[] memory) {
        uint256[] memory eligiblePools = new uint256[](nextPoolId - 1);
        uint256 count = 0;
        
        // Collect eligible pools
        for (uint256 i = 1; i < nextPoolId; i++) {
            if (this.isPoolEligibleForBid(i)) {
                eligiblePools[count] = i;
                count++;
            }
        }
        
        // Resize array to actual count
        uint256[] memory result = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            result[i] = eligiblePools[i];
        }
        
        // Sort by pool amount (descending) - largest pools bid first
        _sortPoolsByAmount(result);
        
        return result;
    }
    
    /**
     * @dev Sort pools by amount (descending)
     */
    function _sortPoolsByAmount(uint256[] memory poolIds) internal view {
        for (uint256 i = 0; i < poolIds.length - 1; i++) {
            for (uint256 j = i + 1; j < poolIds.length; j++) {
                if (pools[poolIds[i]].currentAmount < pools[poolIds[j]].currentAmount) {
                    uint256 temp = poolIds[i];
                    poolIds[i] = poolIds[j];
                    poolIds[j] = temp;
                }
            }
        }
    }
    
    /**
     * @dev Check if an auction is currently active
     */
    function _isAuctionActive() internal view returns (bool) {
        // This would integrate with the auction manager contract
        // For now, returning false as placeholder
        return false;
    }
    
    /**
     * @dev Emergency pause function
     */
    function pause() external onlyOwner {
        _pause();
    }
    
    /**
     * @dev Unpause function
     */
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /**
     * @dev Update contract addresses
     */
    function updateAuctionManager(address _auctionManager) external onlyOwner {
        auctionManager = _auctionManager;
    }
    
    function updateRewardDistributor(address _rewardDistributor) external onlyOwner {
        rewardDistributor = _rewardDistributor;
    }
    
    function updateCrossChainRewardManager(address _crossChainRewardManager) external onlyOwner {
        crossChainRewardManager = _crossChainRewardManager;
    }
}

/**
 * @title AuctionManager
 * @dev Manages multiple simultaneous auctions with unique IDs
 */
contract AuctionManager is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    
    IPNDCPoolManager public poolManager;
    IERC20 public pndcToken;
    
    // Track multiple active auctions
    mapping(uint256 => PoolStructs.AuctionState) public auctions;
    mapping(uint256 => bool) public activeAuctions;
    uint256[] public activeAuctionIds;
    uint256 public nextAuctionId;
    
    event AuctionStarted(uint256 indexed auctionId, uint256 startTime, uint256 endTime, uint256[] eligiblePools);
    event BidPlaced(uint256 indexed auctionId, uint256 indexed poolId, uint256 amount);
    event AuctionEnded(uint256 indexed auctionId, uint256[] winningPools);
    
    constructor(address _poolManager, address _pndcToken) {
        poolManager = IPNDCPoolManager(_poolManager);
        pndcToken = IERC20(_pndcToken);
        nextAuctionId = 1;
    }
    
    /**
     * @dev Start a new auction with unique ID
     */
    function startAuction(uint256 externalAuctionId, uint256 duration) external onlyOwner returns (uint256) {
        require(!activeAuctions[externalAuctionId], "Auction ID already exists");
        
        // Get eligible pools from pool manager
        uint256[] memory eligiblePools = PNDCPoolManager(address(poolManager)).getEligiblePools();
        require(eligiblePools.length > 0, "No eligible pools");
        
        uint256 auctionId = externalAuctionId > 0 ? externalAuctionId : nextAuctionId++;
        
        PoolStructs.AuctionState storage auction = auctions[auctionId];
        auction.auctionId = auctionId;
        auction.isActive = true;
        auction.startTime = block.timestamp;
        auction.endTime = block.timestamp + duration;
        auction.eligiblePools = eligiblePools;
        
        activeAuctions[auctionId] = true;
        activeAuctionIds.push(auctionId);
        
        emit AuctionStarted(auctionId, auction.startTime, auction.endTime, eligiblePools);
        
        return auctionId;
    }
    
    /**
     * @dev Place bid for specific auction
     */
    function placeBid(uint256 auctionId) external nonReentrant returns (uint256[] memory winningPools) {
        require(activeAuctions[auctionId], "Auction not active");
        
        PoolStructs.AuctionState storage auction = auctions[auctionId];
        require(auction.isActive, "Auction not active");
        require(block.timestamp <= auction.endTime, "Auction has ended");
        
        // Get eligible pools and select winners (could be multiple)
        uint256[] memory eligiblePools = auction.eligiblePools;
        require(eligiblePools.length > 0, "No eligible pools");
        
        // For now, select the largest pool as winner
        // In practice, this could select multiple pools based on auction rules
        uint256 winningPoolId = eligiblePools[0];
        
        // Mark pool as winner
        poolManager.markPoolAsWinner(winningPoolId, auctionId);
        
        // Track winning pools
        auction.winningPools.push(winningPoolId);
        auction.poolWon[winningPoolId] = true;
        auction.isActive = false;
        
        // Remove from active auctions
        activeAuctions[auctionId] = false;
        _removeFromActiveAuctions(auctionId);
        
        // Get pool info for bid amount
        (, , uint256 bidAmount, , , , , , ) = poolManager.getPoolInfo(winningPoolId);
        
        emit BidPlaced(auctionId, winningPoolId, bidAmount);
        emit AuctionEnded(auctionId, auction.winningPools);
        
        return auction.winningPools;
    }
    
    /**
     * @dev End auction manually
     */
    function endAuction(uint256 auctionId) external onlyOwner {
        require(activeAuctions[auctionId], "Auction not active");
        
        auctions[auctionId].isActive = false;
        activeAuctions[auctionId] = false;
        _removeFromActiveAuctions(auctionId);
        
        emit AuctionEnded(auctionId, auctions[auctionId].winningPools);
    }
    
    /**
     * @dev Get specific auction state
     */
    function getAuction(uint256 auctionId) external view returns (
        uint256 id,
        bool isActive,
        uint256 startTime,
        uint256 endTime,
        uint256[] memory eligiblePools,
        uint256[] memory winningPools
    ) {
        PoolStructs.AuctionState storage auction = auctions[auctionId];
        return (
            auction.auctionId,
            auction.isActive,
            auction.startTime,
            auction.endTime,
            auction.eligiblePools,
            auction.winningPools
        );
    }
    
    /**
     * @dev Get all active auction IDs
     */
    function getActiveAuctions() external view returns (uint256[] memory) {
        return activeAuctionIds;
    }
    
    /**
     * @dev Check if specific auction is active
     */
    function isAuctionActive(uint256 auctionId) external view returns (bool) {
        return activeAuctions[auctionId] && auctions[auctionId].isActive;
    }
    
    /**
     * @dev Remove auction from active list
     */
    function _removeFromActiveAuctions(uint256 auctionId) internal {
        for (uint256 i = 0; i < activeAuctionIds.length; i++) {
            if (activeAuctionIds[i] == auctionId) {
                activeAuctionIds[i] = activeAuctionIds[activeAuctionIds.length - 1];
                activeAuctionIds.pop();
                break;
            }
        }
    }
}

/**
 * @title CrossChainRewardManager
 * @dev Handles cross-chain reward distribution and coordination
 */
contract CrossChainRewardManager is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    
    IPNDCPoolManager public poolManager;
    address public bridgeContract;
    
    // Chain identifiers
    uint8 public constant ETHEREUM_CHAIN = 1;
    uint8 public constant SOLANA_CHAIN = 2;
    
    struct RewardDistribution {
        uint256 auctionId;
        uint256 poolId;
        address rewardToken;
        uint256 totalAmount;
        uint8 sourceChain;
        uint8 targetChain;
        mapping(address => uint256) userAllocations;
        bool calculated;
        bool distributed;
        bytes32 distributionHash;
    }
    
    mapping(bytes32 => RewardDistribution) public distributions; // hash(auctionId, poolId, chain)
    mapping(address => bool) public authorizedMultisigs;
    mapping(uint8 => mapping(address => bool)) public chainMultisigs; // chain => multisig => authorized
    
    event RewardDistributionInitiated(bytes32 indexed distributionId, uint256 auctionId, uint256 poolId, uint8 targetChain);
    event CrossChainMessageSent(bytes32 indexed messageId, uint8 targetChain, bytes data);
    event RewardCalculated(bytes32 indexed distributionId, uint256 totalUsers, uint256 totalAmount);
    event CrossChainRewardDistributed(bytes32 indexed distributionId, address indexed user, uint256 amount);
    
    constructor(address _poolManager, address _bridgeContract) {
        poolManager = IPNDCPoolManager(_poolManager);
        bridgeContract = _bridgeContract;
    }
    
    /**
     * @dev Authorize multisig for specific chain
     */
    function authorizeChainMultisig(uint8 chainId, address multisig) external onlyOwner {
        chainMultisigs[chainId][multisig] = true;
        authorizedMultisigs[multisig] = true;
    }
    
    /**
     * @dev Initiate cross-chain reward distribution
     */
    function initiateCrossChainDistribution(
        uint256 auctionId,
        uint256 poolId,
        address rewardToken,
        uint256 amount,
        uint8 sourceChain,
        uint8 targetChain
    ) external onlyOwner returns (bytes32) {
        require(targetChain == ETHEREUM_CHAIN || targetChain == SOLANA_CHAIN, "Invalid target chain");
        require(sourceChain != targetChain, "Source and target chain cannot be same");
        
        bytes32 distributionId = keccak256(abi.encodePacked(auctionId, poolId, targetChain, block.timestamp));
        
        RewardDistribution storage distribution = distributions[distributionId];
        distribution.auctionId = auctionId;
        distribution.poolId = poolId;
        distribution.rewardToken = rewardToken;
        distribution.totalAmount = amount;
        distribution.sourceChain = sourceChain;
        distribution.targetChain = targetChain;
        distribution.calculated = false;
        distribution.distributed = false;
        
        emit RewardDistributionInitiated(distributionId, auctionId, poolId, targetChain);
        
        // Calculate user allocations
        _calculateUserAllocations(distributionId);
        
        return distributionId;
    }
    
    /**
     * @dev Calculate proportional reward allocations for users
     */
    function _calculateUserAllocations(bytes32 distributionId) internal {
        RewardDistribution storage distribution = distributions[distributionId];
        
        // Get pool info and contributors
        (, , uint256 totalPoolAmount, , , , , , ) = poolManager.getPoolInfo(distribution.poolId);
        
        // This would get all contributors and their contributions
        // For now, this is simplified - in practice would iterate through all contributors
        
        distribution.calculated = true;
        distribution.distributionHash = keccak256(abi.encodePacked(distributionId, totalPoolAmount));
        
        emit RewardCalculated(distributionId, 0, distribution.totalAmount); // 0 users for now
    }
    
    /**
     * @dev Execute cross-chain distribution via bridge
     */
    function executeCrossChainDistribution(bytes32 distributionId) external onlyOwner {
        RewardDistribution storage distribution = distributions[distributionId];
        require(distribution.calculated, "Allocations not calculated");
        require(!distribution.distributed, "Already distributed");
        
        // Prepare cross-chain message
        bytes memory message = abi.encode(
            distributionId,
            distribution.auctionId,
            distribution.poolId,
            distribution.rewardToken,
            distribution.totalAmount
        );
        
        // Send via bridge contract
        bytes32 messageId = keccak256(abi.encodePacked(message, block.timestamp));
        
        // This would integrate with actual bridge contract
        emit CrossChainMessageSent(messageId, distribution.targetChain, message);
        
        distribution.distributed = true;
    }
    
    /**
     * @dev Process incoming cross-chain reward distribution
     */
    function processCrossChainReward(
        bytes32 distributionId,
        uint256 auctionId,
        uint256 poolId,
        address rewardToken,
        uint256 amount,
        bytes calldata proof
    ) external {
        require(authorizedMultisigs[msg.sender], "Not authorized multisig");
        
        // Verify proof and process distribution
        // This would include signature verification and replay protection
        
        RewardDistribution storage distribution = distributions[distributionId];
        require(!distribution.distributed, "Already processed");
        
        distribution.distributed = true;
        
        // Notify pool manager of successful cross-chain distribution
        // In practice, this would trigger actual token distributions
    }
    
    /**
     * @dev Get distribution info
     */
    function getDistribution(bytes32 distributionId) external view returns (
        uint256 auctionId,
        uint256 poolId,
        address rewardToken,
        uint256 totalAmount,
        uint8 sourceChain,
        uint8 targetChain,
        bool calculated,
        bool distributed
    ) {
        RewardDistribution storage distribution = distributions[distributionId];
        return (
            distribution.auctionId,
            distribution.poolId,
            distribution.rewardToken,
            distribution.totalAmount,
            distribution.sourceChain,
            distribution.targetChain,
            distribution.calculated,
            distribution.distributed
        );
    }
}

/**
 * @title RewardDistributor
 * @dev Enhanced reward distribution with auction ID and cross-chain support
 */
contract RewardDistributor is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    
    IPNDCPoolManager public poolManager;
    CrossChainRewardManager public crossChainManager;
    address public bridgeContract;
    
    mapping(address => bool) public supportedRewardTokens;
    mapping(bytes32 => bool) public rewardsProcessed; // hash(auctionId, poolId)
    mapping(uint256 => mapping(uint256 => bool)) public auctionRewardsProcessed; // auctionId => poolId => processed
    
    event RewardTokenAdded(address indexed token);
    event RewardTokenRemoved(address indexed token);
    event RewardsProcessed(uint256 indexed poolId, uint256 indexed auctionId, address rewardToken, uint256 amount);
    event SPLTokensBridged(uint256 indexed auctionId, address indexed splToken, uint256 amount, uint256 ethReceived);
    event CrossChainRewardDetected(uint256 indexed auctionId, uint256 indexed poolId, uint8 targetChain);
    
    constructor(address _poolManager, address _crossChainManager, address _bridgeContract) {
        poolManager = IPNDCPoolManager(_poolManager);
        crossChainManager = CrossChainRewardManager(_crossChainManager);
        bridgeContract = _bridgeContract;
    }
    
    /**
     * @dev Add supported reward token
     */
    function addSupportedRewardToken(address token) external onlyOwner {
        supportedRewardTokens[token] = true;
        emit RewardTokenAdded(token);
    }
    
    /**
     * @dev Remove supported reward token
     */
    function removeSupportedRewardToken(address token) external onlyOwner {
        supportedRewardTokens[token] = false;
        emit RewardTokenRemoved(token);
    }
    
    /**
     * @dev Process rewards for a specific auction winner
     */
    function processRewards(
        uint256 poolId,
        uint256 auctionId,
        address rewardToken,
        uint256 amount,
        bool isSPLToken,
        uint8 targetChain
    ) external nonReentrant onlyOwner {
        bytes32 rewardKey = keccak256(abi.encodePacked(auctionId, poolId));
        require(!rewardsProcessed[rewardKey], "Rewards already processed for this auction");
        require(!auctionRewardsProcessed[auctionId][poolId], "Auction rewards already processed");
        require(supportedRewardTokens[rewardToken] || isSPLToken, "Unsupported reward token");
        
        if (isSPLToken) {
            // Bridge SPL tokens and determine target chain
            uint256 bridgedAmount = _bridgeAndSwapSPLToEth(auctionId, rewardToken, amount);
            
            if (targetChain == 2) { // Solana
                // Initiate cross-chain distribution back to Solana
                crossChainManager.initiateCrossChainDistribution(
                    auctionId, poolId, address(0), bridgedAmount, 1, 2 // ETH to SOL
                );
                emit CrossChainRewardDetected(auctionId, poolId, targetChain);
            } else {
                // Distribute on Ethereum
                poolManager.distributeRewards(poolId, auctionId, address(0), bridgedAmount, 1);
            }
            
            emit SPLTokensBridged(auctionId, rewardToken, amount, bridgedAmount);
        } else {
            // Direct ERC-20 or ETH distribution
            if (targetChain == 1) { // Ethereum
                IERC20(rewardToken).safeTransfer(address(poolManager), amount);
                poolManager.distributeRewards(poolId, auctionId, rewardToken, amount, 1);
            } else { // Cross-chain to Solana
                crossChainManager.initiateCrossChainDistribution(
                    auctionId, poolId, rewardToken, amount, 1, 2
                );
                emit CrossChainRewardDetected(auctionId, poolId, targetChain);
            }
        }
        
        rewardsProcessed[rewardKey] = true;
        auctionRewardsProcessed[auctionId][poolId] = true;
        
        emit RewardsProcessed(poolId, auctionId, rewardToken, amount);
    }
    
    /**
     * @dev Bridge SPL tokens and swap to ETH
     */
    function _bridgeAndSwapSPLToEth(uint256 auctionId, address splToken, uint256 amount) internal returns (uint256) {
        require(bridgeContract != address(0), "Bridge contract not set");
        
        // In a real implementation, this would:
        // 1. Call bridge contract to convert SPL to ERC-20
        // 2. Swap ERC-20 to ETH via DEX
        // 3. Return ETH amount
        
        // For now, returning amount as placeholder
        return amount;
    }
    
    /**
     * @dev Process multiple auction rewards in batch
     */
    function batchProcessRewards(
        uint256[] calldata poolIds,
        uint256[] calldata auctionIds,
        address[] calldata rewardTokens,
        uint256[] calldata amounts,
        bool[] calldata isSPLTokens,
        uint8[] calldata targetChains
    ) external onlyOwner {
        require(poolIds.length == auctionIds.length, "Array length mismatch");
        require(auctionIds.length == rewardTokens.length, "Array length mismatch");
        require(rewardTokens.length == amounts.length, "Array length mismatch");
        require(amounts.length == isSPLTokens.length, "Array length mismatch");
        require(isSPLTokens.length == targetChains.length, "Array length mismatch");
        
        for (uint256 i = 0; i < poolIds.length; i++) {
            this.processRewards(
                poolIds[i],
                auctionIds[i], 
                rewardTokens[i],
                amounts[i],
                isSPLTokens[i],
                targetChains[i]
            );
        }
    }
    
    /**
     * @dev Check if auction rewards have been processed
     */
    function areAuctionRewardsProcessed(uint256 auctionId, uint256 poolId) external view returns (bool) {
        return auctionRewardsProcessed[auctionId][poolId];
    }
    
    /**
     * @dev Get reward processing status
     */
    function getRewardStatus(uint256 auctionId, uint256 poolId) external view returns (bool processed, bytes32 rewardKey) {
        rewardKey = keccak256(abi.encodePacked(auctionId, poolId));
        processed = rewardsProcessed[rewardKey];
    }
    
    /**
     * @dev Update bridge contract
     */
    function updateBridgeContract(address _bridgeContract) external onlyOwner {
        bridgeContract = _bridgeContract;
    }
    
    /**
     * @dev Update cross-chain manager
     */
    function updateCrossChainManager(address _crossChainManager) external onlyOwner {
        crossChainManager = CrossChainRewardManager(_crossChainManager);
    }
    
    /**
     * @dev Emergency withdrawal function
     */
    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        if (token == address(0)) {
            payable(owner()).transfer(amount);
        } else {
            IERC20(token).safeTransfer(owner(), amount);
        }
    }
    
    // Allow contract to receive ETH
    receive() external payable {}
}

/**
 * @title MultisigWalletManager
 * @dev Enhanced multisig management with cross-chain support
 */
contract MultisigWalletManager is Ownable {
    
    struct MultisigWallet {
        address walletAddress;
        address[] owners;
        uint256 threshold;
        uint8 chainId; // 1 = Ethereum, 2 = Solana
        bool isActive;
        bytes32 linkedWallet; // Link to corresponding wallet on other chain
    }
    
    struct CrossChainWalletPair {
        address ethWallet;
        address solWallet;
        bool isLinked;
        uint256 poolId;
    }
    
    mapping(uint256 => mapping(uint8 => MultisigWallet)) public poolWallets; // poolId => chainId => wallet
    mapping(uint256 => CrossChainWalletPair) public walletPairs; // poolId => wallet pair
    mapping(address => bool) public authorizedWallets;
    mapping(uint8 => mapping(address => bool)) public chainAuthorizedWallets; // chainId => wallet => authorized
    
    event MultisigWalletCreated(uint256 indexed poolId, uint8 indexed chainId, address walletAddress, address[] owners, uint256 threshold);
    event CrossChainWalletsLinked(uint256 indexed poolId, address ethWallet, address solWallet);
    event MultisigWalletUpdated(uint256 indexed poolId, uint8 indexed chainId, address newWalletAddress);
    
    /**
     * @dev Create cross-chain multisig wallet pair for a pool
     */
    function createCrossChainMultisigPair(
        uint256 poolId,
        address ethWalletAddress,
        address[] memory ethOwners,
        uint256 ethThreshold,
        address solWalletAddress,
        address[] memory solOwners,
        uint256 solThreshold
    ) external onlyOwner {
        require(ethOwners.length >= ethThreshold && ethThreshold > 0, "Invalid ETH threshold");
        require(solOwners.length >= solThreshold && solThreshold > 0, "Invalid SOL threshold");
        
        // Create Ethereum multisig
        MultisigWallet storage ethWallet = poolWallets[poolId][1];
        ethWallet.walletAddress = ethWalletAddress;
        ethWallet.owners = ethOwners;
        ethWallet.threshold = ethThreshold;
        ethWallet.chainId = 1;
        ethWallet.isActive = true;
        
        // Create Solana multisig
        MultisigWallet storage solWallet = poolWallets[poolId][2];
        solWallet.walletAddress = solWalletAddress;
        solWallet.owners = solOwners;
        solWallet.threshold = solThreshold;
        solWallet.chainId = 2;
        solWallet.isActive = true;
        
        // Link wallets
        bytes32 ethHash = keccak256(abi.encodePacked(ethWalletAddress, uint8(1)));
        bytes32 solHash = keccak256(abi.encodePacked(solWalletAddress, uint8(2)));
        ethWallet.linkedWallet = solHash;
        solWallet.linkedWallet = ethHash;
        
        // Create wallet pair
        CrossChainWalletPair storage pair = walletPairs[poolId];
        pair.ethWallet = ethWalletAddress;
        pair.solWallet = solWalletAddress;
        pair.isLinked = true;
        pair.poolId = poolId;
        
        // Authorize wallets
        authorizedWallets[ethWalletAddress] = true;
        authorizedWallets[solWalletAddress] = true;
        chainAuthorizedWallets[1][ethWalletAddress] = true;
        chainAuthorizedWallets[2][solWalletAddress] = true;
        
        emit MultisigWalletCreated(poolId, 1, ethWalletAddress, ethOwners, ethThreshold);
        emit MultisigWalletCreated(poolId, 2, solWalletAddress, solOwners, solThreshold);
        emit CrossChainWalletsLinked(poolId, ethWalletAddress, solWalletAddress);
    }
    
    /**
     * @dev Get multisig wallet for specific pool and chain
     */
    function getPoolWallet(uint256 poolId, uint8 chainId) external view returns (
        address walletAddress,
        address[] memory owners,
        uint256 threshold,
        bool isActive
    ) {
        MultisigWallet storage wallet = poolWallets[poolId][chainId];
        return (wallet.walletAddress, wallet.owners, wallet.threshold, wallet.isActive);
    }
    
    /**
     * @dev Get cross-chain wallet pair for pool
     */
    function getWalletPair(uint256 poolId) external view returns (address ethWallet, address solWallet, bool isLinked) {
        CrossChainWalletPair storage pair = walletPairs[poolId];
        return (pair.ethWallet, pair.solWallet, pair.isLinked);
    }
    
    /**
     * @dev Update multisig wallet for specific chain
     */
    function updatePoolWallet(uint256 poolId, uint8 chainId, address newWalletAddress) external onlyOwner {
        require(poolWallets[poolId][chainId].walletAddress != address(0), "Wallet does not exist");
        
        // Deauthorize old wallet
        address oldWallet = poolWallets[poolId][chainId].walletAddress;
        authorizedWallets[oldWallet] = false;
        chainAuthorizedWallets[chainId][oldWallet] = false;
        
        // Update wallet address
        poolWallets[poolId][chainId].walletAddress = newWalletAddress;
        
        // Authorize new wallet
        authorizedWallets[newWalletAddress] = true;
        chainAuthorizedWallets[chainId][newWalletAddress] = true;
        
        // Update wallet pair
        if (chainId == 1) {
            walletPairs[poolId].ethWallet = newWalletAddress;
        } else if (chainId == 2) {
            walletPairs[poolId].solWallet = newWalletAddress;
        }
        
        emit MultisigWalletUpdated(poolId, chainId, newWalletAddress);
    }
    
    /**
     * @dev Check if wallet is authorized for specific chain
     */
    function isChainWalletAuthorized(uint8 chainId, address wallet) external view returns (bool) {
        return chainAuthorizedWallets[chainId][wallet];
    }
    
    /**
     * @dev Check if wallet is authorized (any chain)
     */
    function isAuthorizedWallet(address wallet) external view returns (bool) {
        return authorizedWallets[wallet];
    }
    
    /**
     * @dev Get linked wallet address
     */
    function getLinkedWallet(uint256 poolId, uint8 chainId) external view returns (address) {
        if (chainId == 1) {
            return walletPairs[poolId].solWallet;
        } else if (chainId == 2) {
            return walletPairs[poolId].ethWallet;
        }
        return address(0);
    }
}

/**
 * @title BridgeContract
 * @dev Enhanced bridge with auction ID tracking
 */
contract BridgeContract is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    
    mapping(address => bool) public supportedTokens;
    mapping(bytes32 => bool) public processedTransactions;
    mapping(uint256 => mapping(bytes32 => bool)) public auctionTransactions; // auctionId => txHash => processed
    
    event TokensBridged(uint256 indexed auctionId, address indexed token, uint256 amount, bytes32 txHash, uint8 targetChain);
    event TokensReceived(uint256 indexed auctionId, address indexed token, uint256 amount, bytes32 txHash, uint8 sourceChain);
    event CrossChainRewardBridged(uint256 indexed auctionId, uint256 indexed poolId, address token, uint256 amount);
    
    /**
     * @dev Bridge tokens with auction ID tracking
     */
    function bridgeTokensWithAuction(
        uint256 auctionId,
        address token,
        uint256 amount,
        uint8 targetChain
    ) external nonReentrant returns (bytes32) {
        require(supportedTokens[token], "Token not supported");
        require(auctionId > 0, "Invalid auction ID");
        
        // Transfer tokens to bridge
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        
        bytes32 txHash = keccak256(abi.encodePacked(auctionId, token, amount, block.timestamp, msg.sender));
        require(!auctionTransactions[auctionId][txHash], "Transaction already processed");
        
        auctionTransactions[auctionId][txHash] = true;
        processedTransactions[txHash] = true;
        
        emit TokensBridged(auctionId, token, amount, txHash, targetChain);
        
        return txHash;
    }
    
    /**
     * @dev Receive bridged tokens with auction tracking
     */
    function receiveBridgedTokens(
        uint256 auctionId,
        address token,
        uint256 amount,
        bytes32 sourceTxHash,
        uint8 sourceChain,
        bytes calldata proof
    ) external onlyOwner nonReentrant {
        require(supportedTokens[token], "Token not supported");
        require(!auctionTransactions[auctionId][sourceTxHash], "Transaction already processed");
        
        // Verify proof (simplified)
        require(proof.length > 0, "Invalid proof");
        
        auctionTransactions[auctionId][sourceTxHash] = true;
        processedTransactions[sourceTxHash] = true;
        
        // Mint or release tokens
        IERC20(token).safeTransfer(msg.sender, amount);
        
        emit TokensReceived(auctionId, token, amount, sourceTxHash, sourceChain);
    }
    
    /**
     * @dev Bridge rewards for specific auction and pool
     */
    function bridgeAuctionRewards(
        uint256 auctionId,
        uint256 poolId,
        address token,
        uint256 amount,
        uint8 targetChain
    ) external onlyOwner {
        bytes32 txHash = bridgeTokensWithAuction(auctionId, token, amount, targetChain);
        
        emit CrossChainRewardBridged(auctionId, poolId, token, amount);
    }
    
    /**
     * @dev Check if auction transaction was processed
     */
    function isAuctionTransactionProcessed(uint256 auctionId, bytes32 txHash) external view returns (bool) {
        return auctionTransactions[auctionId][txHash];
    }
    
    /**
     * @dev Add supported token
     */
    function addSupportedToken(address token) external onlyOwner {
        supportedTokens[token] = true;
    }
    
    /**
     * @dev Remove supported token
     */
    function removeSupportedToken(address token) external onlyOwner {
        supportedTokens[token] = false;
    }
}
