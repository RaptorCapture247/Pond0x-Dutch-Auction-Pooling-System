"function getRewardStatus(uint256,uint256) view returns (bool,bytes32)",
        "function addSupportedRewardToken(address)",
        "event RewardsProcessed(uint256 indexed,uint256 indexed,address,uint256)",
        "event SPLTokensBridged(uint256 indexed,address indexed,uint256,uint256)",
        "event CrossChainRewardDetected(uint256 indexed,uint256 indexed,uint8)"
    ],
    crossChainRewardManager: [
        "function initiateCrossChainDistribution(uint256,uint256,address,uint256,uint8,uint8) returns (bytes32)",
        "function executeCrossChainDistribution(bytes32)",
        "function getDistribution(bytes32) view returns (uint256,uint256,address,uint256,uint8,uint8,bool,bool)",
        "function authorizeChainMultisig(uint8,address)",
        "event RewardDistributionInitiated(bytes32 indexed,uint256,uint256,uint8)",
        "event CrossChainMessageSent(bytes32 indexed,uint8,bytes)",
        "event CrossChainRewardDistributed(bytes32 indexed,address indexed,uint256)"
    ],
    bridgeContract: [
        "function bridgeTokensWithAuction(uint256,address,uint256,uint8) returns (bytes32)",
        "function receiveBridgedTokens(uint256,address,uint256,bytes32,uint8,bytes)",
        "function bridgeAuctionRewards(uint256,uint256,address,uint256,uint8)",
        "function isAuctionTransactionProcessed(uint256,bytes32) view returns (bool)",
        "event TokensBridged(uint256 indexed,address indexed,uint256,bytes32,uint8)",
        "event CrossChainRewardBridged(uint256 indexed,uint256 indexed,address,uint256)"
    ]
};

// Logger setup with enhanced auction tracking
const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json(),
        winston.format.printf(info => {
            return JSON.stringify({
                timestamp: info.timestamp,
                level: info.level,
                message: info.message,
                auctionId: info.auctionId || null,
                poolId: info.poolId || null,
                chain: info.chain || null,
                ...info
            });
        })
    ),
    transports: [
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'auction.log', level: 'info' }),
        new winston.transports.Console({
            format: winston.format.simple()
        })
    ]
});

// Redis client for cross-chain coordination
const redis = Redis.createClient(CONFIG.redis);

// Enhanced Base Bot Class with Auction ID Support
class BaseBot {
    constructor(name) {
        this.name = name;
        this.isRunning = false;
        this.retryCount = 0;
        this.maxRetries = CONFIG.monitoring.maxRetries;
        this.activeAuctions = new Map(); // Track active auctions
        
        // Initialize Web3 and ethers
        this.web3 = new Web3(CONFIG.ethereum.rpcUrl);
        this.provider = new ethers.providers.JsonRpcProvider(CONFIG.ethereum.rpcUrl);
        this.wallet = new ethers.Wallet(CONFIG.ethereum.privateKey, this.provider);
        
        // Initialize Solana connection
        this.solanaConnection = new Connection(CONFIG.solana.rpcUrl);
        this.solanaKeypair = CONFIG.solana.privateKey ? 
            Keypair.fromSecretKey(Buffer.from(CONFIG.solana.privateKey, 'hex')) : null;
        
        // Initialize contracts
        this.initializeContracts();
    }
    
    initializeContracts() {
        this.poolManager = new ethers.Contract(
            CONFIG.contracts.poolManager,
            ABIS.poolManager,
            this.wallet
        );
        
        this.auctionManager = new ethers.Contract(
            CONFIG.contracts.auctionManager,
            ABIS.auctionManager,
            this.wallet
        );
        
        this.rewardDistributor = new ethers.Contract(
            CONFIG.contracts.rewardDistributor,
            ABIS.rewardDistributor,
            this.wallet
        );
        
        this.crossChainRewardManager = new ethers.Contract(
            CONFIG.contracts.crossChainRewardManager,
            ABIS.crossChainRewardManager,
            this.wallet
        );
        
        this.bridgeContract = new ethers.Contract(
            CONFIG.contracts.bridgeContract,
            ABIS.bridgeContract,
            this.wallet
        );
    }
    
    async start() {
        logger.info(`Starting ${this.name} bot`);
        this.isRunning = true;
        await this.run();
    }
    
    async stop() {
        logger.info(`Stopping ${this.name} bot`);
        this.isRunning = false;
    }
    
    async run() {
        throw new Error('run() method must be implemented');
    }
    
    async retry(operation, context = '') {
        let lastError;
        
        for (let i = 0; i < this.maxRetries; i++) {
            try {
                return await operation();
            } catch (error) {
                lastError = error;
                logger.warn(`Retry ${i + 1}/${this.maxRetries} failed for ${context}: ${error.message}`);
                
                if (i < this.maxRetries - 1) {
                    await this.sleep(1000 * Math.pow(2, i));
                }
            }
        }
        
        throw lastError;
    }
    
    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    async sendAlert(message, level = 'warning', metadata = {}) {
        try {
            if (CONFIG.monitoring.alertWebhook) {
                await axios.post(CONFIG.monitoring.alertWebhook, {
                    text: `[${level.toUpperCase()}] ${this.name}: ${message}`,
                    timestamp: new Date().toISOString(),
                    metadata
                });
            }
            
            logger.log(level, message, metadata);
        } catch (error) {
            logger.error(`Failed to send alert: ${error.message}`);
        }
    }
    
    // Enhanced logging with auction context
    logWithContext(message, level = 'info', auctionId = null, poolId = null, chain = null) {
        logger.log(level, message, { auctionId, poolId, chain, bot: this.name });
    }
}

// Enhanced Pond0x Auction Monitor Bot with Multiple Auction Support
class Pond0xAuctionBot extends BaseBot {
    constructor() {
        super('Pond0xAuctionBot');
        this.trackedAuctions = new Map(); // auctionId => auction data
        this.auctionCheckInterval = CONFIG.monitoring.checkInterval;
    }
    
    async run() {
        while (this.isRunning) {
            try {
                await this.checkForAuctions();
                await this.checkAuctionResults();
                await this.sleep(this.auctionCheckInterval);
            } catch (error) {
                this.logWithContext(`Auction monitoring error: ${error.message}`, 'error');
                await this.sendAlert(`Auction monitoring failed: ${error.message}`, 'error');
                await this.sleep(this.auctionCheckInterval);
            }
        }
    }
    
    async checkForAuctions() {
        const auctionData = await this.retry(
            () => this.fetchActiveAuctions(),
            'fetching auction data'
        );
        
        // Check for new auctions
        for (const auction of auctionData.active) {
            if (!this.trackedAuctions.has(auction.id)) {
                await this.handleNewAuction(auction);
            }
        }
        
        // Check for ended auctions
        for (const [auctionId, trackedAuction] of this.trackedAuctions) {
            const stillActive = auctionData.active.find(a => a.id === auctionId);
            if (!stillActive && trackedAuction.isActive) {
                await this.handleAuctionEnd(auctionId);
            }
        }
    }
    
    async fetchActiveAuctions() {
        const [statusResponse, activeResponse] = await Promise.all([
            axios.get(`${CONFIG.pond0x.baseUrl}${CONFIG.pond0x.statusEndpoint}`, {
                headers: { 'Authorization': `Bearer ${CONFIG.pond0x.apiKey}` }
            }),
            axios.get(`${CONFIG.pond0x.baseUrl}/api/auctions/active`, {
                headers: { 'Authorization': `Bearer ${CONFIG.pond0x.apiKey}` }
            })
        ]);
        
        return {
            status: statusResponse.data,
            active: activeResponse.data.auctions || []
        };
    }
    
    async handleNewAuction(auctionData) {
        this.logWithContext('New Pond0x auction detected', 'info', auctionData.id);
        
        // Store auction data
        this.trackedAuctions.set(auctionData.id, {
            ...auctionData,
            isActive: true,
            startedAt: Date.now(),
            internalAuctionId: null
        });
        
        // Store in Redis for other bots
        await redis.setex(
            `auction_${auctionData.id}`,
            auctionData.duration || 3600,
            JSON.stringify(auctionData)
        );
        
        // Start internal auction with Pond0x auction ID
        const internalAuctionId = await this.startInternalAuction(auctionData);
        
        // Update tracked auction with internal ID
        const tracked = this.trackedAuctions.get(auctionData.id);
        tracked.internalAuctionId = internalAuctionId;
        
        await this.sendAlert(
            `New auction started: ${auctionData.id} - Duration: ${auctionData.duration}s`,
            'info',
            { auctionId: auctionData.id, internalAuctionId }
        );
    }
    
    async startInternalAuction(auctionData) {
        try {
            // Use Pond0x auction ID as external auction ID
            const tx = await this.auctionManager.startAuction(auctionData.id, auctionData.duration);
            const receipt = await tx.wait();
            
            // Extract internal auction ID from events
            const auctionStartedEvent = receipt.events?.find(e => e.event === 'AuctionStarted');
            const internalAuctionId = auctionStartedEvent?.args?.auctionId || auctionData.id;
            
            this.logWithContext(
                `Internal auction started: ${tx.hash}`, 
                'info', 
                auctionData.id, 
                null, 
                'ethereum'
            );
            
            // Notify other bots
            await redis.publish('auction_started', JSON.stringify({
                externalAuctionId: auctionData.id,
                internalAuctionId: internalAuctionId,
                duration: auctionData.duration,
                txHash: tx.hash,
                eligiblePools: auctionStartedEvent?.args?.eligiblePools || []
            }));
            
            return internalAuctionId;
            
        } catch (error) {
            this.logWithContext(`Failed to start internal auction: ${error.message}`, 'error', auctionData.id);
            await this.sendAlert(`Failed to start internal auction: ${error.message}`, 'error', { auctionId: auctionData.id });
            throw error;
        }
    }
    
    async handleAuctionEnd(auctionId) {
        this.logWithContext('Pond0x auction ended', 'info', auctionId);
        
        const tracked = this.trackedAuctions.get(auctionId);
        if (tracked) {
            tracked.isActive = false;
            tracked.endedAt = Date.now();
            
            // End internal auction if it exists
            if (tracked.internalAuctionId) {
                try {
                    const tx = await this.auctionManager.endAuction(tracked.internalAuctionId);
                    await tx.wait();
                    
                    this.logWithContext(`Internal auction ended: ${tx.hash}`, 'info', auctionId);
                } catch (error) {
                    this.logWithContext(`Failed to end internal auction: ${error.message}`, 'error', auctionId);
                }
            }
        }
        
        // Clean up Redis
        await redis.del(`auction_${auctionId}`);
        
        // Notify other bots
        await redis.publish('auction_ended', JSON.stringify({
            externalAuctionId: auctionId,
            internalAuctionId: tracked?.internalAuctionId,
            timestamp: Date.now()
        }));
        
        await this.sendAlert(`Auction ended: ${auctionId}`, 'info', { auctionId });
    }
    
    async checkAuctionResults() {
        // Check for auction results and prepare reward distribution
        try {
            const resultsResponse = await axios.get(
                `${CONFIG.pond0x.baseUrl}${CONFIG.pond0x.resultsEndpoint}`,
                {
                    headers: { 'Authorization': `Bearer ${CONFIG.pond0x.apiKey}` }
                }
            );
            
            for (const result of resultsResponse.data.results || []) {
                if (!this.trackedAuctions.has(result.auctionId)) continue;
                
                const tracked = this.trackedAuctions.get(result.auctionId);
                if (!tracked.resultsProcessed) {
                    await this.processAuctionResult(result);
                    tracked.resultsProcessed = true;
                }
            }
            
        } catch (error) {
            this.logWithContext(`Failed to check auction results: ${error.message}`, 'error');
        }
    }
    
    async processAuctionResult(result) {
        this.logWithContext('Processing auction result', 'info', result.auctionId);
        
        // Store result data for reward processing
        await redis.setex(
            `auction_result_${result.auctionId}`,
            86400, // 24 hours
            JSON.stringify(result)
        );
        
        // Notify reward distribution bot
        await redis.publish('auction_result', JSON.stringify(result));
        
        this.logWithContext('Auction result processed', 'info', result.auctionId);
    }
}

// Enhanced Pool Monitor Bot with Auction ID Tracking
class PoolMonitorBot extends BaseBot {
    constructor() {
        super('PoolMonitorBot');
        this.trackedPools = new Map();
        this.auctionPools = new Map(); // auctionId => poolIds
        this.lastBlockProcessed = 0;
    }
    
    async run() {
        this.setupEventListeners();
        
        while (this.isRunning) {
            try {
                await this.checkPoolStates();
                await this.checkExpiredPools();
                await this.monitorCrossChainEvents();
                await this.sleep(CONFIG.monitoring.checkInterval);
            } catch (error) {
                this.logWithContext(`Pool monitoring error: ${error.message}`, 'error');
                await this.sleep(CONFIG.monitoring.checkInterval);
            }
        }
    }
    
    setupEventListeners() {
        // Enhanced pool creation listener with cross-chain support
        this.poolManager.on('PoolCreated', async (poolId, creator, labelToken, goal, deadline, ethMultisig, solMultisig) => {
            this.logWithContext(`New pool created: ${poolId.toString()}`, 'info', null, poolId.toString());
            
            this.trackedPools.set(poolId.toString(), {
                id: poolId.toString(),
                creator,
                labelToken,
                goal: goal.toString(),
                deadline: deadline.toString(),
                ethMultisig,
                solMultisig,
                lastChecked: Date.now(),
                auctions: [] // Track which auctions this pool participated in
            });
            
            await this.sendAlert(
                `New pool created: ${poolId.toString()} with goal ${ethers.utils.formatEther(goal)} PNDC`,
                'info',
                { poolId: poolId.toString(), goal: goal.toString() }
            );
        });
        
        // Enhanced pool won listener with auction ID
        this.poolManager.on('PoolWon', async (poolId, auctionId, bidAmount) => {
            this.logWithContext(
                `Pool ${poolId.toString()} won auction ${auctionId.toString()}`,
                'info',
                auctionId.toString(),
                poolId.toString()
            );
            
            const pool = this.trackedPools.get(poolId.toString());
            if (pool) {
                pool.hasWon = true;
                pool.winningAuctionId = auctionId.toString();
                pool.winAmount = bidAmount.toString();
                if (!pool.auctions.includes(auctionId.toString())) {
                    pool.auctions.push(auctionId.toString());
                }
            }
            
            // Track auction-pool relationship
            if (!this.auctionPools.has(auctionId.toString())) {
                this.auctionPools.set(auctionId.toString(), []);
            }
            this.auctionPools.get(auctionId.toString()).push(poolId.toString());
            
            await this.sendAlert(
                `Pool ${poolId.toString()} won auction ${auctionId.toString()}!`,
                'info',
                { poolId: poolId.toString(), auctionId: auctionId.toString() }
            );
        });
        
        // Cross-chain reward initiation listener
        this.poolManager.on('CrossChainRewardInitiated', async (poolId, auctionId, targetChain) => {
            this.logWithContext(
                `Cross-chain reward initiated for pool ${poolId.toString()}`,
                'info',
                auctionId.toString(),
                poolId.toString(),
                targetChain === 1 ? 'ethereum' : 'solana'
            );
            
            // Store cross-chain reward info
            await redis.setex(
                `cross_chain_reward_${poolId}_${auctionId}`,
                3600,
                JSON.stringify({
                    poolId: poolId.toString(),
                    auctionId: auctionId.toString(),
                    targetChain,
                    timestamp: Date.now()
                })
            );
        });
        
        // Enhanced rewards received listener with auction ID
        this.poolManager.on('RewardsReceived', async (poolId, auctionId, rewardToken, amount, targetChain) => {
            this.logWithContext(
                `Rewards received for pool ${poolId.toString()} from auction ${auctionId.toString()}`,
                'info',
                auctionId.toString(),
                poolId.toString(),
                targetChain === 1 ? 'ethereum' : 'solana'
            );
            
            const pool = this.trackedPools.get(poolId.toString());
            if (pool) {
                if (!pool.rewards) pool.rewards = {};
                pool.rewards[auctionId.toString()] = {
                    token: rewardToken,
                    amount: amount.toString(),
                    targetChain,
                    received: true
                };
            }
        });
        
        // Enhanced rewards distributed listener
        this.poolManager.on('RewardsDistributed', async (poolId, auctionId, user, amount) => {
            this.logWithContext(
                `Rewards distributed to ${user} from pool ${poolId.toString()} auction ${auctionId.toString()}`,
                'info',
                auctionId.toString(),
                poolId.toString()
            );
        });
    }
    
    async checkPoolStates() {
        const eligiblePools = await this.poolManager.getEligiblePools();
        
        for (const poolId of eligiblePools) {
            const poolInfo = await this.poolManager.getPoolInfo(poolId);
            const multisigs = await this.poolManager.getPoolMultisigs(poolId);
            
            // Update tracked pool data
            const tracked = this.trackedPools.get(poolId.toString()) || {};
            tracked.lastChecked = Date.now();
            tracked.currentAmount = poolInfo.currentAmount.toString();
            tracked.goalMet = poolInfo.goalMet;
            tracked.hasWon = poolInfo.hasWon;
            tracked.winningAuctionId = poolInfo.winningAuctionId.toString();
            tracked.ethMultisig = multisigs.ethMultisig;
            tracked.solMultisig = multisigs.solMultisig;
            
            this.trackedPools.set(poolId.toString(), tracked);
            
            // Store in Redis for other bots
            await redis.setex(
                `pool_${poolId}`,
                3600,
                JSON.stringify(tracked)
            );
        }
    }
    
    async monitorCrossChainEvents() {
        // Monitor cross-chain reward events and coordinate between chains
        try {
            // Check for pending cross-chain rewards
            const crossChainKeys = await redis.keys('cross_chain_reward_*');
            
            for (const key of crossChainKeys) {
                const rewardInfo = JSON.parse(await redis.get(key));
                const timeSinceInitiated = Date.now() - rewardInfo.timestamp;
                
                // Alert if cross-chain reward is taking too long
                if (timeSinceInitiated > 300000) { // 5 minutes
                    await this.sendAlert(
                        `Cross-chain reward delayed: Pool ${rewardInfo.poolId}, Auction ${rewardInfo.auctionId}`,
                        'warning',
                        rewardInfo
                    );
                }
            }
            
        } catch (error) {
            this.logWithContext(`Cross-chain monitoring error: ${error.message}`, 'error');
        }
    }
    
    async checkExpiredPools() {
        const now = Date.now() / 1000;
        
        for (const [poolId, pool] of this.trackedPools) {
            if (parseInt(pool.deadline) < now && !pool.hasWon && !pool.processed) {
                await this.handleExpiredPool(poolId);
            }
        }
    }
    
    async handleExpiredPool(poolId) {
        try {
            this.logWithContext(`Processing expired pool: ${poolId}`, 'info', null, poolId);
            
            const pool = this.trackedPools.get(poolId);
            if (pool) {
                pool.processed = true;
                pool.expired = true;
            }
            
            await this.sendAlert(`Pool ${poolId} has expired`, 'warning', { poolId });
            
        } catch (error) {
            this.logWithContext(`Failed to process expired pool ${poolId}: ${error.message}`, 'error', null, poolId);
        }
    }
}

// Enhanced Bidding Bot with Multiple Auction Support
class BiddingBot extends BaseBot {
    constructor() {
        super('BiddingBot');
        this.activeAuctions = new Map(); // auctionId => auction state
        this.biddingStrategies = new Map(); // auctionId => strategy
        this.setupSubscriptions();
    }
    
    setupSubscriptions() {
        const subscriber = redis.duplicate();
        
        subscriber.subscribe('auction_started', (message) => {
            const data = JSON.parse(message);
            this.handleAuctionStart(data);
        });
        
        subscriber.subscribe('auction_ended', (message) => {
            const data = JSON.parse(message);
            this.handleAuctionEnd(data);
        });
    }
    
    async run() {
        while (this.isRunning) {
            if (this.activeAuctions.size > 0) {
                await this.checkBiddingOpportunities();
            }
            await this.sleep(5000); // Check every 5 seconds during auctions
        }
    }
    
    async handleAuctionStart(auctionData) {
        this.logWithContext('Auction started, enabling bidding', 'info', auctionData.externalAuctionId);
        
        this.activeAuctions.set(auctionData.externalAuctionId, {
            externalId: auctionData.externalAuctionId,
            internalId: auctionData.internalAuctionId,
            duration: auctionData.duration,
            eligiblePools: auctionData.eligiblePools,
            startTime: Date.now(),
            bidPlaced: false
        });
        
        // Wait for blockchain sync
        await this.sleep(10000);
        
        await this.evaluateBiddingStrategy(auctionData.externalAuctionId);
    }
    
    async handleAuctionEnd(auctionData) {
        this.logWithContext('Auction ended, disabling bidding', 'info', auctionData.externalAuctionId);
        
        const auction = this.activeAuctions.get(auctionData.externalAuctionId);
        if (auction) {
            auction.ended = true;
            auction.endTime = Date.now();
            
            // Clean up after some time
            setTimeout(() => {
                this.activeAuctions.delete(auctionData.externalAuctionId);
            }, 60000); // Keep for 1 minute for analysis
        }
    }
    
    async evaluateBiddingStrategy(auctionId) {
        try {
            const auction = this.activeAuctions.get(auctionId);
            if (!auction || auction.bidPlaced) return;
            
            // Get current auction state from contract
            const auctionState = await this.auctionManager.getAuction(auction.internalId);
            
            if (!auctionState.isActive) {
                this.logWithContext('Auction not active on contract', 'info', auctionId);
                return;
            }
            
            // Evaluate bidding decision
            const shouldBid = await this.evaluateBiddingDecision(auction, auctionState);
            
            if (shouldBid) {
                await this.placeBid(auctionId, auction.internalId);
            }
            
        } catch (error) {
            this.logWithContext(`Bidding strategy evaluation error: ${error.message}`, 'error', auctionId);
        }
    }
    
    async evaluateBiddingDecision(auction, auctionState) {
        if (auctionState.eligiblePools.length === 0) {
            this.logWithContext('No eligible pools for bidding', 'info', auction.externalId);
            return false;
        }
        
        // Get pool information for decision making
        const poolInfos = await Promise.all(
            auctionState.eligiblePools.map(poolId => this.poolManager.getPoolInfo(poolId))
        );
        
        // Sort by current amount (descending)
        poolInfos.sort((a, b) => b.currentAmount.sub(a.currentAmount));
        
        const largestPool = poolInfos[0];
        const secondLargest = poolInfos[1];
        
        // Only bid if largest pool has significant lead (>10%) or if there's only one pool
        if (secondLargest) {
            const leadPercentage = largestPool.currentAmount
                .sub(secondLargest.currentAmount)
                .mul(100)
                .div(largestPool.currentAmount);
            
            if (leadPercentage.lt(10)) {
                this.logWithContext('Waiting for clearer leader before bidding', 'info', auction.externalId);
                return false;
            }
        }
        
        // Check time constraints - bid in last 30% of auction duration
        const timeElapsed = Date.now() - auction.startTime;
        const timeRemaining = auction.duration * 1000 - timeElapsed;
        const timeThreshold = auction.duration * 1000 * 0.3; // Last 30%
        
        if (timeRemaining > timeThreshold) {
            this.logWithContext('Too early to bid, waiting for optimal timing', 'info', auction.externalId);
            return false;
        }
        
        return true;
    }
    
    async placeBid(externalAuctionId, internalAuctionId) {
        try {
            const auction = this.activeAuctions.get(externalAuctionId);
            if (auction.bidPlaced) return;
            
            this.logWithContext('Placing bid for eligible pools', 'info', externalAuctionId);
            
            const gasPrice = await this.provider.getGasPrice();
            const tx = await this.auctionManager.placeBid(internalAuctionId, {
                gasPrice: gasPrice.mul(120).div(100), // 20% above current gas price
                gasLimit: CONFIG.ethereum.gasLimit
            });
            
            this.logWithContext(`Bid placed: ${tx.hash}`, 'info', externalAuctionId);
            auction.bidPlaced = true;
            auction.bidTxHash = tx.hash;
            
            const receipt = await tx.wait();
            
            if (receipt.status === 1) {
                // Extract winning pools from events
                const bidPlacedEvents = receipt.events?.filter(e => e.event === 'BidPlaced') || [];
                const winningPools = bidPlacedEvents.map(e => e.args.poolId.toString());
                
                auction.winningPools = winningPools;
                
                this.logWithContext(
                    `Bid confirmed: ${tx.hash}, Winning pools: ${winningPools.join(', ')}`,
                    'info',
                    externalAuctionId
                );
                
                await this.sendAlert(
                    `Bid successfully placed for auction ${externalAuctionId}: ${tx.hash}`,
                    'info',
                    { auctionId: externalAuctionId, txHash: tx.hash, winningPools }
                );
            } else {
                this.logWithContext(`Bid transaction failed: ${tx.hash}`, 'error', externalAuctionId);
                await this.sendAlert(`Bid transaction failed: ${tx.hash}`, 'error', { auctionId: externalAuctionId });
            }
            
        } catch (error) {
            this.logWithContext(`Failed to place bid: ${error.message}`, 'error', externalAuctionId);
            await this.sendAlert(`Failed to place bid for auction ${externalAuctionId}: ${error.message}`, 'error');
        }
    }
    
    async checkBiddingOpportunities() {
        for (const [auctionId, auction] of this.activeAuctions) {
            if (auction.ended || auction.bidPlaced) continue;
            
            try {
                const auctionState = await this.auctionManager.getAuction(auction.internalId);
                
                if (auctionState.isActive && !auctionState.winningPools.length) {
                    // Check if conditions are right for bidding
                    const timeRemaining = auctionState.endTime - (Date.now() / 1000);
                    
                    if (timeRemaining > 0 && timeRemaining < 300) { // Last 5 minutes
                        await this.evaluateBiddingStrategy(auctionId);
                    }
                }
                
            } catch (error) {
                this.logWithContext(`Error checking bidding opportunity: ${error.message}`, 'error', auctionId);
            }
        }
    }
}

// Enhanced Reward Distribution Bot with Cross-Chain Support
class RewardDistributionBot extends BaseBot {
    constructor() {
        super('RewardDistributionBot');
        this.pendingRewards = new Map(); // auctionId => reward data
        this.crossChainRewards = new Map(); // distributionId => cross-chain data
        this.setupSubscriptions();
    }
    
    setupSubscriptions() {
        const subscriber = redis.duplicate();
        
        subscriber.subscribe('auction_result', (message) => {
            const result = JSON.parse(message);
            this.handleAuctionResult(result);
        });
    }
    
    async run() {
        // Listen for pool wins with auction IDs
        this.poolManager.on('PoolWon', async (poolId, auctionId, bidAmount) => {
            await this.handlePoolWin(poolId.toString(), auctionId.toString(), bidAmount.toString());
        });
        
        // Listen for cross-chain reward events
        this.poolManager.on('CrossChainRewardInitiated', async (poolId, auctionId, targetChain) => {
            await this.handleCrossChainRewardInitiation(poolId.toString(), auctionId.toString(), targetChain);
        });
        
        while (this.isRunning) {
            await this.checkPendingRewards();
            await this.processCrossChainRewards();
            await this.sleep(CONFIG.monitoring.checkInterval);
        }
    }
    
    async handlePoolWin(poolId, auctionId, bidAmount) {
        this.logWithContext(`Pool ${poolId} won auction ${auctionId}`, 'info', auctionId, poolId);
        
        const rewardKey = `${auctionId}_${poolId}`;
        this.pendingRewards.set(rewardKey, {
            poolId,
            auctionId,
            bidAmount,
            timestamp: Date.now(),
            status: 'pending',
            rewardsReceived: false
        });
        
        // Store in Redis for persistence
        await redis.setex(`pending_reward_${rewardKey}`, 3600, JSON.stringify({
            poolId,
            auctionId,
            bidAmount,
            timestamp: Date.now()
        }));
        
        this.logWithContext(`Reward tracking initiated for pool ${poolId}, auction ${auctionId}`, 'info', auctionId, poolId);
    }
    
    async handleAuctionResult(auctionResult) {
        this.logWithContext(`Processing auction result for ${auctionResult.auctionId}`, 'info', auctionResult.auctionId);
        
        // Get winning pools for this auction
        try {
            const winningPools = await this.poolManager.getAuctionWinners(auctionResult.auctionId);
            
            for (const poolId of winningPools) {
                await this.processRewardForPool(
                    poolId.toString(),
                    auctionResult.auctionId,
                    auctionResult.rewards
                );
            }
            
        } catch (error) {
            this.logWithContext(`Failed to process auction result: ${error.message}`, 'error', auctionResult.auctionId);
        }
    }
    
    async processRewardForPool(poolId, auctionId, rewardData) {
        try {
            this.logWithContext(`Processing reward for pool ${poolId}, auction ${auctionId}`, 'info', auctionId, poolId);
            
            // Determine target chain based on reward type and pool configuration
            const multisigs = await this.poolManager.getPoolMultisigs(poolId);
            const targetChain = this.determineTargetChain(rewardData, multisigs);
            
            // Process rewards through reward distributor
            const tx = await this.rewardDistributor.processRewards(
                poolId,
                auctionId,
                rewardData.tokenAddress,
                ethers.utils.parseEther(rewardData.amount.toString()),
                rewardData.isSPL || false,
                targetChain
            );
            
            await tx.wait();
            
            this.logWithContext(`Reward processed for pool ${poolId}, auction ${auctionId}: ${tx.hash}`, 'info', auctionId, poolId);
            
            // Update pending rewards
            const rewardKey = `${auctionId}_${poolId}`;
            const pending = this.pendingRewards.get(rewardKey);
            if (pending) {
                pending.status = 'processed';
                pending.txHash = tx.hash;
                pending.targetChain = targetChain;
            }
            
            await this.sendAlert(
                `Rewards processed for pool ${poolId}, auction ${auctionId}`,
                'info',
                { poolId, auctionId, txHash: tx.hash }
            );
            
        } catch (error) {
            this.logWithContext(`Failed to process reward: ${error.message}`, 'error', auctionId, poolId);
            await this.sendAlert(`Failed to process reward for pool ${poolId}, auction ${auctionId}: ${error.message}`, 'error');
        }
    }
    
    determineTargetChain(rewardData, multisigs) {
        // Logic to determine whether rewards should go to Ethereum or Solana
        // Based on reward type, user preferences, gas costs, etc.
        
        if (rewardData.preferredChain) {
            return rewardData.preferredChain === 'ethereum' ? 1 : 2;
        }
        
        // Default: SPL tokens go to Solana, ERC-20 tokens stay on Ethereum
        if (rewardData.isSPL) {
            return 2; // Solana
        } else {
            return 1; // Ethereum
        }
    }
    
    async handleCrossChainRewardInitiation(poolId, auctionId, targetChain) {
        this.logWithContext(
            `Cross-chain reward initiated for pool ${poolId}, auction ${auctionId}`,
            'info',
            auctionId,
            poolId,
            targetChain === 1 ? 'ethereum' : 'solana'
        );
        
        // Track cross-chain distribution
        const distributionKey = `${auctionId}_${poolId}_${targetChain}`;
        this.crossChainRewards.set(distributionKey, {
            poolId,
            auctionId,
            targetChain,
            status: 'initiated',
            timestamp: Date.now()
        });
    }
    
    async processCrossChainRewards() {
        for (const [key, crossChainReward] of this.crossChainRewards) {
            if (crossChainReward.status === 'initiated') {
                try {
                    // Check if cross-chain distribution is complete
                    const timeSinceInitiation = Date.now() - crossChainReward.timestamp;
                    
                    if (timeSinceInitiation > 600000) { // 10 minutes
                        this.logWithContext(
                            `Cross-chain reward taking too long: ${key}`,
                            'warning',
                            crossChainReward.auctionId,
                            crossChainReward.poolId
                        );
                        
                        await this.sendAlert(
                            `Cross-chain reward delayed: Pool ${crossChainReward.poolId}, Auction ${crossChainReward.auctionId}`,
                            'warning',
                            crossChainReward
                        );
                    }
                    
                } catch (error) {
                    this.logWithContext(`Cross-chain reward processing error: ${error.message}`, 'error');
                }
            }
        }
    }
    
    async checkPendingRewards() {
        for (const [rewardKey, reward] of this.pendingRewards) {
            if (reward.status === 'pending') {
                const timeSinceWin = Date.now() - reward.timestamp;
                
                // Alert if reward is pending too long
                if (timeSinceWin > 300000 && !reward.alertSent) { // 5 minutes
                    this.logWithContext(
                        `Reward for pool ${reward.poolId}, auction ${reward.auctionId} still pending after 5 minutes`,
                        'warning',
                        reward.auctionId,
                        reward.poolId
                    );
                    
                    await this.sendAlert(
                        `Reward distribution delayed for pool ${reward.poolId}, auction ${reward.auctionId}`,
                        'warning',
                        reward
                    );
                    
                    reward.alertSent = true;
                }
                
                // Check if we have auction results for this reward
                const auctionResult = await redis.get(`auction_result_${reward.auctionId}`);
                if (auctionResult && !reward.rewardsReceived) {
                    const result = JSON.parse(auctionResult);
                    await this.processRewardForPool(reward.poolId, reward.auctionId, result.rewards);
                    reward.rewardsReceived = true;
                }
            }
        }
    }
    
    async batchProcessRewards(rewardsData) {
        try {
            const poolIds = [];
            const auctionIds = [];
            const rewardTokens = [];
            const amounts = [];
            const isSPLTokens = [];
            const targetChains = [];
            
            for (const reward of rewardsData) {
                poolIds.push(reward.poolId);
                auctionIds.push(reward.auctionId);
                rewardTokens.push(reward.tokenAddress);
                amounts.push(ethers.utils.parseEther(reward.amount.toString()));
                isSPLTokens.push(reward.isSPL || false);
                targetChains.push(reward.targetChain || 1);
            }
            
            const tx = await this.rewardDistributor.batchProcessRewards(
                poolIds,
                auctionIds,
                rewardTokens,
                amounts,
                isSPLTokens,
                targetChains
            );
            
            await tx.wait();
            
            this.logWithContext(`Batch rewards processed: ${tx.hash}`, 'info');
            
        } catch (error) {
            this.logWithContext(`Batch reward processing failed: ${error.message}`, 'error');
            throw error;
        }
    }
}

// Enhanced Cross-Chain Coordinator Bot
class CrossChainCoordinatorBot extends BaseBot {
    constructor() {
        super('CrossChainCoordinatorBot');
        this.pendingDistributions = new Map();
        this.chainStates = new Map();
        this.bridgeOperations = new Map();
    }
    
    async run() {
        // Monitor cross-chain events
        this.crossChainRewardManager.on('RewardDistributionInitiated', async (distributionId, auctionId, poolId, targetChain) => {
            await this.handleDistributionInitiation(distributionId, auctionId.toString(), poolId.toString(), targetChain);
        });
        
        this.crossChainRewardManager.on('CrossChainMessageSent', async (messageId, targetChain, data) => {
            await this.handleCrossChainMessage(messageId, targetChain, data);
        });
        
        this.bridgeContract.on('CrossChainRewardBridged', async (auctionId, poolId, token, amount) => {
            await this.handleBridgeOperation(auctionId.toString(), poolId.toString(), token, amount.toString());
        });
        
        while (this.isRunning) {
            await this.coordinateCrossChainOperations();
            await this.monitorBridgeOperations();
            await this.syncChainStates();
            await this.sleep(CONFIG.monitoring.checkInterval);
        }
    }
    
    async handleDistributionInitiation(distributionId, auctionId, poolId, targetChain) {
        this.logWithContext(
            `Cross-chain distribution initiated: ${distributionId}`,
            'info',
            auctionId,
            poolId,
            targetChain === 1 ? 'ethereum' : 'solana'
        );
        
        this.pendingDistributions.set(distributionId, {
            distributionId,
            auctionId,
            poolId,
            targetChain,
            status: 'initiated',
            timestamp: Date.now()
        });
        
        // Execute the distribution after a brief delay
        setTimeout(() => {
            this.executeCrossChainDistribution(distributionId);
        }, 30000); // 30 second delay
    }
    
    async executeCrossChainDistribution(distributionId) {
        try {
            const distribution = this.pendingDistributions.get(distributionId);
            if (!distribution) return;
            
            this.logWithContext(
                `Executing cross-chain distribution: ${distributionId}`,
                'info',
                distribution.auctionId,
                distribution.poolId
            );
            
            const tx = await this.crossChainRewardManager.executeCrossChainDistribution(distributionId);
            await tx.wait();
            
            distribution.status = 'executed';
            distribution.txHash = tx.hash;
            
            this.logWithContext(
                `Cross-chain distribution executed: ${tx.hash}`,
                'info',
                distribution.auctionId,
                distribution.poolId
            );
            
        } catch (error) {
            this.logWithContext(`Failed to execute cross-chain distribution: ${error.message}`, 'error');
        }
    }
    
    async handleCrossChainMessage(messageId, targetChain, data) {
        this.logWithContext(
            `Cross-chain message sent: ${messageId} to chain ${targetChain}`,
            'info',
            null,
            null,
            targetChain === 1 ? 'ethereum' : 'solana'
        );
        
        // Track message for confirmation
        this.bridgeOperations.set(messageId, {
            messageId,
            targetChain,
            data,
            status: 'sent',
            timestamp: Date.now()
        });
    }
    
    async handleBridgeOperation(auctionId, poolId, token, amount) {
        this.logWithContext(
            `Bridge operation completed for auction ${auctionId}, pool ${poolId}`,
            'info',
            auctionId,
            poolId
        );
        
        // Update bridge operation status
        for (const [messageId, operation] of this.bridgeOperations) {
            // Match bridge operation with pending messages
            const decodedData = ethers.utils.defaultAbiCoder.decode(
                ['bytes32', 'uint256', 'uint256', 'address', 'uint256'],
                operation.data
            );
            
            if (decodedData[1].toString() === auctionId && decodedData[2].toString() === poolId) {
                operation.status = 'completed';
                operation.completedAt = Date.now();
                break;
            }
        }
    }
    
    async coordinateCrossChainOperations() {
        // Coordinate pending cross-chain operations
        for (const [distributionId, distribution] of this.pendingDistributions) {
            if (distribution.status === 'initiated') {
                const timeSinceInitiation = Date.now() - distribution.timestamp;
                
                // Auto-execute after 2 minutes if not already executed
                if (timeSinceInitiation > 120000 && distribution.status === 'initiated') {
                    await this.executeCrossChainDistribution(distributionId);
                }
                
                // Alert if taking too long
                if (timeSinceInitiation > 600000) { // 10 minutes
                    await this.sendAlert(
                        `Cross-chain distribution delayed: ${distributionId}`,
                        'warning',
                        distribution
                    );
                }
            }
        }
    }
    
    async monitorBridgeOperations() {
        // Monitor bridge operations for completion
        for (const [messageId, operation] of this.bridgeOperations) {
            if (operation.status === 'sent') {
                const timeSinceSent = Date.now() - operation.timestamp;
                
                // Alert if bridge operation is taking too long
                if (timeSinceSent > 900000) { // 15 minutes
                    await this.sendAlert(
                        `Bridge operation delayed: ${messageId}`,
                        'warning',
                        operation
                    );
                }
                
                // Clean up old completed operations
                if (timeSinceSent > 3600000) { // 1 hour
                    this.bridgeOperations.delete(messageId);
                }
            }
        }
    }
    
    async syncChainStates() {
        // Synchronize state between Ethereum and Solana
        try {
            // Get Ethereum state
            const ethState = {
                blockNumber: await this.provider.getBlockNumber(),
                gasPrice: await this.provider.getGasPrice(),
                timestamp: Date.now()
            };
            
            // Get Solana state
            const solState = {
                blockHeight: await this.solanaConnection.getBlockHeight(),
                timestamp: Date.now()
            };
            
            this.chainStates.set('ethereum', ethState);
            this.chainStates.set('solana', solState);
            
            // Store in Redis for other bots
            await redis.setex('chain_state_ethereum', 300, JSON.stringify(ethState));
            await redis.setex('chain_state_solana', 300, JSON.stringify(solState));
            
        } catch (error) {
            this.logWithContext(`Chain state sync error: ${error.message}`, 'error');
        }
    }
}

// Enhanced Security Monitor Bot with Auction Tracking
class SecurityMonitorBot extends BaseBot {
    constructor() {
        super('SecurityMonitorBot');
        this.suspiciousActivities = new Map();
        this.auctionActivities = new Map(); // Track per-auction activities
        this.rateLimit = new Map();
    }
    
    async run() {
        // Monitor for suspicious activities with auction context
        this.poolManager.on('ContributionMade', (poolId, contributor, amount) => {
            this.checkContributionPattern(poolId.toString(), contributor, amount);
        });
        
        this.poolManager.on('PoolCreated', (poolId, creator) => {
            this.checkPoolCreationPattern(poolId.toString(), creator);
        });
        
        this.poolManager.on('PoolWon', (poolId, auctionId, bidAmount) => {
            this.trackAuctionWin(poolId.toString(), auctionId.toString(), bidAmount);
        });
        
        while (this.isRunning) {
            await this.performSecurityChecks();
            await this.analyzeAuctionPatterns();
            await this.checkCrossChainSecurity();
            await this.sleep(CONFIG.monitoring.checkInterval);
        }
    }
    
    async trackAuctionWin(poolId, auctionId, bidAmount) {
        if (!this.auctionActivities.has(auctionId)) {
            this.auctionActivities.set(auctionId, {
                winners: [],
                totalAmount: ethers.BigNumber.from(0),
                timestamp: Date.now()
            });
        }
        
        const auctionActivity = this.auctionActivities.get(auctionId);
        auctionActivity.winners.push(poolId);
        auctionActivity.totalAmount = auctionActivity.totalAmount.add(bidAmount);
        
        // Check for suspicious auction patterns
        if (auctionActivity.winners.length > 3) {
            await this.flagSuspiciousActivity(
                auctionId,
                'multiple_winners_single_auction',
                { winnerCount: auctionActivity.winners.length, auctionId }
            );
        }
    }
    
    async analyzeAuctionPatterns() {
        // Analyze patterns across auctions
        for (const [auctionId, activity] of this.auctionActivities) {
            const age = Date.now() - activity.timestamp;
            
            // Clean up old auction data
            if (age > 86400000) { // 24 hours
                this.auctionActivities.delete(auctionId);
                continue;
            }
            
            // Analyze for manipulation patterns
            if (activity.winners.length > 1) {
                // Check if same addresses are winning multiple auctions
                await this.checkWinnerPatterns(auctionId, activity);
            }
        }
    }
    
    async checkWinnerPatterns(auctionId, activity) {
        // This would implement sophisticated pattern analysis
        // to detect potential manipulation across auctions
        
        const recentWinners = new Set();
        const recentAuctions = Array.from(this.auctionActivities.entries())
            .filter(([id, data]) => Date.now() - data.timestamp < 3600000) // Last hour
            .map(([id, data]) => ({ id, winners: data.winners }));
        
        for (const auction of recentAuctions) {
            for (const winner of auction.winners) {
                if (recentWinners.has(winner)) {
                    await this.flagSuspiciousActivity(
                        winner,
                        'frequent_auction_winner',
                        { 
                            winnerAddress: winner,
                            auctionCount: recentAuctions.filter(a => a.winners.includes(winner)).length
                        }
                    );
                }
                recentWinners.add(winner);
            }
        }
    }
    
    async checkCrossChainSecurity() {
        // Monitor cross-chain operations for security issues
        try {
            const crossChainKeys = await redis.keys('cross_chain_reward_*');
            
            for (const key of crossChainKeys) {
                const rewardInfo = JSON.parse(await redis.get(key));
                
                // Check for suspicious cross-chain patterns
                if (rewardInfo.targetChain && rewardInfo.auctionId) {
                    await this.validateCrossChainOperation(rewardInfo);
                }
            }
            
        } catch (error) {
            this.logWithContext(`Cross-chain security check error: ${error.message}`, 'error');
        }
    }
    
    async validateCrossChainOperation(rewardInfo) {
        // Validate cross-chain operations for security
        const { poolId, auctionId, targetChain } = rewardInfo;
        
        // Check if auction actually exists and pool won
        try {
            const auctionWinners = await this.poolManager.getAuctionWinners(auctionId);
            const poolWon = auctionWinners.some(winner => winner.toString() === poolId);
            
            if (!poolWon) {
                await this.flagSuspiciousActivity(
                    `${auctionId}_${poolId}`,
                    'invalid_cross_chain_reward',
                    { poolId, auctionId, targetChain }
                );
            }
            
        } catch (error) {
            this.logWithContext(`Cross-chain validation error: ${error.message}`, 'error');
        }
    }
    
    async flagSuspiciousActivity(identifier, type, details) {
        const key = `${identifier}-${type}`;
        
        if (this.suspiciousActivities.has(key)) {
            return; // Already flagged
        }
        
        this.suspiciousActivities.set(key, {
            identifier,
            type,
            details,
            timestamp: Date.now(),
            status: 'flagged'
        });
        
        this.logWithContext(`Suspicious activity detected: ${type} for ${identifier}`, 'warning');
        await this.sendAlert(`Suspicious activity: ${type} for ${identifier}`, 'warning', details);
        
        // Store in Redis for investigation
        await redis.setex(
            `suspicious_${key}`,
            86400, // 24 hours
            JSON.stringify({
                identifier,
                type,
                details,
                timestamp: Date.now()
            })
        );
    }
    
    async performSecurityChecks() {
        await Promise.all([
            this.checkContractBalances(),
            this.checkUnusualGasUsage(),
            this.monitorLargeTransactions(),
            this.validateAuctionIntegrity()
        ]);
    }
    
    async checkContractBalances() {
        try {
            const contracts = [
                { name: 'PoolManager', address: CONFIG.contracts.poolManager },
                { name: 'AuctionManager', address: CONFIG.contracts.auctionManager },
                { name: 'RewardDistributor', address: CONFIG.contracts.rewardDistributor },
                { name: 'CrossChainRewardManager', address: CONFIG.contracts.crossChainRewardManager }
            ];
            
            for (const contract of contracts) {
                const balance = await this.provider.getBalance(contract.address);
                const balanceEth = ethers.utils.formatEther(balance);
                
                // Alert if contract balance is unexpectedly high
                if (parseFloat(balanceEth) > 10) { // More than 10 ETH
                    await this.sendAlert(
                        `High ${contract.name} balance detected: ${balanceEth} ETH`,
                        'warning',
                        { contract: contract.name, balance: balanceEth }
                    );
                }
            }
            
        } catch (error) {
            this.logWithContext(`Contract balance check error: ${error.message}`, 'error');
        }
    }
    
    async validateAuctionIntegrity() {
        // Validate auction integrity across multiple auctions
        try {
            const activeAuctions = await this.auctionManager.getActiveAuctions();
            
            for (const auctionId of activeAuctions) {
                const auctionState = await this.auctionManager.getAuction(auctionId);
                
                // Validate auction state consistency
                if (auctionState.isActive && auctionState.endTime < Date.now() / 1000) {
                    await this.sendAlert(
                        `Auction ${auctionId.toString()} is active but past end time`,
                        'warning',
                        { auctionId: auctionId.toString() }
                    );
                }
                
                // Validate eligible pools
                if (auctionState.eligiblePools.length === 0 && auctionState.isActive) {
                    await this.sendAlert(
                        `Active auction ${auctionId.toString()} has no eligible pools`,
                        'warning',
                        { auctionId: auctionId.toString() }
                    );
                }
            }
            
        } catch (error) {
            this.logWithContext(`Auction integrity check error: ${error.message}`, 'error');
        }
    }
    
    async checkUnusualGasUsage() {
        // Monitor for unusual gas usage patterns that might indicate attacks
        try {
            const recentBlocks = [];
            const currentBlock = await this.provider.getBlockNumber();
            
            for (let i = 0; i < 5; i++) {
                const block = await this.provider.getBlock(currentBlock - i);
                recentBlocks.push(block);
            }
            
            const avgGasUsed = recentBlocks.reduce((sum, block) => 
                sum + block.gasUsed.toNumber(), 0) / recentBlocks.length;
            
            if (avgGasUsed > 15000000) { // 15M gas average - unusually high
                await this.sendAlert(
                    `High average gas usage detected: ${avgGasUsed}`,
                    'warning',
                    { avgGasUsed }
                );
            }
            
        } catch (error) {
            this.logWithContext(`Gas usage check error: ${error.message}`, 'error');
        }
    }
    
    async monitorLargeTransactions() {
        // Monitor for unusually large contributions that might indicate manipulation
        const largeTxThreshold = ethers.utils.parseEther('500000000'); // 500M PNDC
        
        // This would be implemented with event filtering to catch large contributions in real-time
        // For now, we'll check recent contributions periodically
    }
}

// Main Bot Manager with Enhanced Coordination
class BotManager {
    constructor() {
        this.bots = new Map();
        this.isRunning = false;
        this.coordinationInterval = null;
    }
    
    async initialize() {
        // Initialize Redis
        await redis.connect();
        
        // Create and register enhanced bots
        this.registerBot('pond0x', new Pond0xAuctionBot());
        this.registerBot('poolMonitor', new PoolMonitorBot());
        this.registerBot('bidding', new BiddingBot());
        this.registerBot('rewards', new RewardDistributionBot());
        this.registerBot('crossChain', new CrossChainCoordinatorBot());
        this.registerBot('security', new SecurityMonitorBot());
        this.registerBot('health', new HealthMonitorBot());
        this.registerBot('analytics', new AnalyticsBot());
        
        logger.info('Enhanced bot manager initialized with auction ID support');
    }
    
    registerBot(name, bot) {
        this.bots.set(name, bot);
        logger.info(`Registered bot: ${name}`);
    }
    
    async startAll() {
        this.isRunning = true;
        
        // Start coordination interval
        this.coordinationInterval = setInterval(() => {
            this.coordinateBots();
        }, 30000); // Every 30 seconds
        
        for (const [name, bot] of this.bots) {
            try {
                await bot.start();
                logger.info(`Started bot: ${name}`);
            } catch (error) {
                logger.error(`Failed to start bot ${name}: ${error.message}`);
            }
        }
    }
    
    async stopAll() {
        this.isRunning = false;
        
        if (this.coordinationInterval) {
            clearInterval(this.coordinationInterval);
        }
        
        for (const [name, bot] of this.bots) {
            try {
                await bot.stop();
                logger.info(`Stopped bot: ${name}`);
            } catch (error) {
                logger.error(`Failed to stop bot ${name}: ${error.message}`);
            }
        }
        
        await redis.disconnect();
    }
    
    // PNDC Bot System - Enhanced for Multiple Auctions & Cross-Chain Support
// Updated to handle auction IDs and cross-chain reward distribution

const Web3 = require('web3');
const { ethers } = require('ethers');
const axios = require('axios');
const cron = require('node-cron');
const winston = require('winston');
const Redis = require('redis');
const { Connection, PublicKey, Keypair } = require('@solana/web3.js');

// Enhanced Configuration with Cross-Chain Support
const CONFIG = {
    ethereum: {
        rpcUrl: process.env.ETH_RPC_URL || 'https://mainnet.infura.io/v3/YOUR_KEY',
        privateKey: process.env.ETH_PRIVATE_KEY,
        gasPrice: process.env.GAS_PRICE || '20000000000',
        gasLimit: process.env.GAS_LIMIT || '500000'
    },
    solana: {
        rpcUrl: process.env.SOLANA_RPC_URL || 'https://api.mainnet-beta.solana.com',
        privateKey: process.env.SOLANA_PRIVATE_KEY,
        programId: process.env.SOLANA_PROGRAM_ID
    },
    contracts: {
        poolManager: process.env.POOL_MANAGER_ADDRESS,
        auctionManager: process.env.AUCTION_MANAGER_ADDRESS,
        rewardDistributor: process.env.REWARD_DISTRIBUTOR_ADDRESS,
        crossChainRewardManager: process.env.CROSS_CHAIN_REWARD_MANAGER_ADDRESS,
        bridgeContract: process.env.BRIDGE_CONTRACT_ADDRESS,
        multisigManager: process.env.MULTISIG_MANAGER_ADDRESS,
        pndcToken: process.env.PNDC_TOKEN_ADDRESS
    },
    pond0x: {
        baseUrl: 'https://pond0x.com',
        auctionEndpoint: '/mining/bid',
        apiKey: process.env.POND0X_API_KEY,
        statusEndpoint: '/api/auction/status',
        resultsEndpoint: '/api/auction/results'
    },
    crossChain: {
        supportedChains: ['ethereum', 'solana'],
        bridgeContracts: {
            ethereum: process.env.ETH_BRIDGE_ADDRESS,
            solana: process.env.SOL_BRIDGE_ADDRESS
        },
        multisigValidation: {
            ethereum: { threshold: 2, timeout: 3600 },
            solana: { threshold: 2, timeout: 3600 }
        },
        chainIds: {
            ethereum: 1,
            solana: 2
        }
    },
    redis: {
        host: process.env.REDIS_HOST || 'localhost',
        port: process.env.REDIS_PORT || 6379,
        password: process.env.REDIS_PASSWORD
    },
    monitoring: {
        checkInterval: 15000, // 15 seconds for auction monitoring
        maxRetries: 3,
        alertWebhook: process.env.ALERT_WEBHOOK_URL
    }
};

// Enhanced Contract ABIs with Auction ID Support
const ABIS = {
    poolManager: [
        "function getPoolInfo(uint256 poolId) view returns (address,uint256,uint256,uint256,bool,bool,bool,address,uint256)",
        "function getPoolMultisigs(uint256 poolId) view returns (address,address)",
        "function getEligiblePools() view returns (uint256[])",
        "function isPoolEligibleForBid(uint256 poolId) view returns (bool)",
        "function createPool(address,uint256,uint256,address,address) returns (uint256)",
        "function contributeToPool(uint256,uint256)",
        "function markPoolAsWinner(uint256,uint256)",
        "function distributeRewards(uint256,uint256,address,uint256,uint8)",
        "function getUserRewardForAuction(uint256,uint256,address) view returns (uint256)",
        "function getAuctionWinners(uint256) view returns (uint256[])",
        "event PoolCreated(uint256 indexed,address indexed,address indexed,uint256,uint256,address,address)",
        "event ContributionMade(uint256 indexed,address indexed,uint256,uint256)",
        "event GoalReached(uint256 indexed,uint256)",
        "event PoolWon(uint256 indexed,uint256 indexed,uint256)",
        "event RewardsReceived(uint256 indexed,uint256 indexed,address,uint256,uint8)",
        "event RewardsDistributed(uint256 indexed,uint256 indexed,address indexed,uint256)",
        "event CrossChainRewardInitiated(uint256 indexed,uint256 indexed,uint8)"
    ],
    auctionManager: [
        "function startAuction(uint256,uint256) returns (uint256)",
        "function placeBid(uint256) returns (uint256[])",
        "function getAuction(uint256) view returns (uint256,bool,uint256,uint256,uint256[],uint256[])",
        "function getActiveAuctions() view returns (uint256[])",
        "function isAuctionActive(uint256) view returns (bool)",
        "function endAuction(uint256)",
        "event AuctionStarted(uint256 indexed,uint256,uint256,uint256[])",
        "event BidPlaced(uint256 indexed,uint256 indexed,uint256)",
        "event AuctionEnded(uint256 indexed,uint256[])"
    ],
    rewardDistributor: [
        "function processRewards(uint256,uint256,address,uint256,bool,uint8)",
        "function batchProcessRewards(uint256[],uint256[],address[],uint256[],bool[],uint8[])",
        "function areAuctionRewardsProcessed(uint256,uint256) view returns (bool)",
        "function getRewardStatus(uint256,uint256) view returns (bool,bytes32
